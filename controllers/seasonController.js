'use strict';

const _ = require('lodash');
const Bookshelf = require('../db/bookshelf');
const Season = require('../models/season');

const controller = {

    //this is just me ES2015ifying your code
    listAll(req, res) {
        Season.fetchAll({withRelated: ['firstPlaceUser']}).then(function (seasons) {
            var out = marshallSeasons(seasons);
            res.json( out );
        })
    },

    //this is just me ES2015ifying your code
    get(req, res) {
        var id = req.params.id;
        if ('latest' == id) {
            id = 1;
        }
        
        //So, I've created two sepeparate functions that both return promises. One fetches the season, the other queries for rankings
        //Since they both return a promise, I can put them both in an array and send it to Promise.all.  Promise.all returns a promise
        //that will resolve when all promises pass in do.  So, I can chain Promise.all into my new assignRankings function. Promise.all
        //will pass along the values of each promise in an arry, so the results of this promise.all call will be:
        //results[0] == season row from db
        //results[1] == rankings rows from db
        //The results come back in the order the promises were passed in, so since fetchSeason was first passed in, it's results are first.
        //Jump down to assignRankings for more details
        Promise.all([fetchSeason(id), queryForRankings()])
            .then(assignRankings)
            .then(out => res.json(out));  //assignRankings returns out, so here I just do a quick inline function to put out on the json
    }
};

//simply returns the promise generated by this query
function fetchSeason(id) {
    return Season.forge({'id': id}).fetch({withRelated: ['firstPlaceUser', 'events.hostUser']});
}

//simply returns the promise generated by this query
function queryForRankings() {
    return Bookshelf.knex.select('user.*').sum('event_result.amount as winnings')
        .from('event_result')
        .innerJoin('user', 'event_result.user_id', 'user.id')
        .innerJoin('event', 'event_result.event_id', 'event.id')
        .innerJoin('season', 'event.season_id', 'season.id')
        .where('season.id', season.get('id'))
        .groupBy('event_result.user_id')
        .orderBy('winnings', 'desc');
}

//So, since this is chained from Promise.all we know that we will be getting an array containing the results of the promises
//in order.  So first I use the new ES6 feature of deconstructing the array, creating the variable seasonRow from seasonAndRankingArray[0]
// and rankingsRows from seasonAndRankingArray[1].  I then do the marshalling on each and return out. (Rather than marshalling, I like
// simply adding getters and setters to the models, it's a little cleaner that way).
// I don't particularly like having to deal with the values in an array like this, which is why the Bluebird await pattern is very appealling
// But in this case it's no big deal.
// Since I return out from this fuction I should be able to chain it into the next call
function assignRankings(seasonAndRankingsArray) {
    const [seasonRow, rankingsRows] = seasonAndRankingArray;
    const out = marshallSeason(seasonRow);
    out.rankings = marshallRankings(rankingsRows);
    return out;
}

function marshallSeasons(seasons) {
    var out = [];
    _(seasons.models).each(function(season) {
        out.push( marshallSeason(season) );
    });
    return out;
}

function marshallSeason(season) {
    return {
        id: season.get('id'),
        year: season.get('year'),
        isActive: season.get('is_active') ? true : false,
        firstPlaceUser: marshallUser(season.related('firstPlaceUser')),
        firstPlaceWinnings: season.get('first_place_winnings'),
        events: marshallEvents(season.related('events').models)
    };
}

function marshallEvents(events) {
    if (events.length == 0) return;
    var out = [];
    _(events).each(function(event) {
        out.push(marshallEvent(event));
    });
    return out;
}

function marshallEvent(event) {
    if (!event.has('id')) return;
    return {
        id: event.get('id'),
        name: event.get('name'),
        eventDate: event.get('event_date'),
        hostUser: marshallUser(event.related('hostUser'))
    };
}

function marshallUser(user) {
    if (!user.has('id')) return;
    return {
        id: user.get('id'),
        nickname: user.get('nickname'),
        fullName: user.get('full_name'),
        isVisitor: user.get('is_visitor') ? true : false
    }
}

function marshallRanking(ranking) {
    if (ranking == undefined) return;
    var out = [];
    _(ranking).each(function(rank, i) {
        out.push({
            rank: i+1,
            user: {
                id: rank.id,
                nickname: rank.nickname,
                fullName: rank.full_name,
                isVisitor: !!rank.is_visitor
            },
            winnings: rank.winnings
        });
    });
    return out;
}

module.exports = controller;
